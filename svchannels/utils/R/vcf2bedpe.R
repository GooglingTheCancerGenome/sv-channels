#!/usr/bin/env Rscript

# debug
# setwd('~/Documents/GitHub/sv-channels/svchannels/')

options(scipen = 999)

suppressPackageStartupMessages(require(StructuralVariantAnnotation))
library(tools)
library(argparser, quietly = TRUE)

script.name <-
  basename(sub(".*=", "", commandArgs()[4])) # script name

# create a parser and add command-line arguments
p <-
  arg_parser("Convert VCF output of Manta, DELLY, LUMPY or GRIDSS to BEDPE format.")
p <-
  add_argument(p, "-i", help = "Input in VCF", type = "character",
               default = '~/Documents/Projects/GTCG/sv-channels/sv-channels_manuscript/1KG_trios/Manta/HG00420/manta.vcf')
p <-
  add_argument(p, "-o", help = "Output in BEDPE", type = "character",
               default = '~/Documents/Projects/GTCG/sv-channels/sv-channels_manuscript/1KG_trios/Manta/HG00420/manta.bedpe')
p <-
  add_argument(p,
               "-p",
               help = "SVTYPE=INS if insertion length >= SV length * p",
               type = "numeric",
               default = 0.7)
p <-
  add_argument(p,
               "-l",
               help = "Minimum SV length to consider",
               type = "int",
               default = 50)

# parse the command line arguments
argv <- parse_args(p)
if (is.na(argv$i))
{
  print(p)
  q(status = 1)
}

if (is.na(argv$o))
{
  argv$o = paste(file_path_sans_ext(argv$i), "bedpe", sep = '../..')
}

# SV types assigned according to
# https://github.com/PapenfussLab/gridss/blob/7b1fedfed32af9e03ed5c6863d368a821a4c699f/example/simple-event-annotation.R#L9
apply_svtype <- function(gr, p_inslen)
{
  gr$svtype <-
    ifelse(
      seqnames(gr) != seqnames(partner(gr)),
      "CTX",
      ifelse(
        gr$insLen >= abs(gr$svLen) * p_inslen,
        "INS",
        ifelse(
          strand(gr) == strand(partner(gr)),
          "INV",
          ifelse(xor(
            start(gr) < start(partner(gr)), strand(gr) == "-"
          ), "DEL",
          "DUP")
        )
      )
    )
  gr
}

sv_callset_vcf <- VariantAnnotation::readVcf(argv$i)

# if the file was generated with SURVIVOR simSV, treat translocations as DELLY TRA entries
if ('source' %in% names(meta(header(sv_callset_vcf)))){
    if (meta(header(sv_callset_vcf))[['source']]$Value == 'Sniffles')
    {
      # Make TRA IDs unique
      sv.names <- names(rowRanges(sv_callset_vcf))
      idx <- grep('TRA', names(rowRanges(sv_callset_vcf)))
      names(rowRanges(sv_callset_vcf))[idx] <-
        paste(sv.names[idx], as.character(1 - idx %% 2 + 1), sep = '_')

      # update info header
      info(header(sv_callset_vcf)) <-
        rbind(info(header(sv_callset_vcf)),
              data.frame(
                Number = '4',
                Type = 'String',
                Description = 'DELLY CT'
              ))
      # update info
      info(sv_callset_vcf) <- cbind(info(sv_callset_vcf),
                                    data.frame(CT = factor(
                                      rep('3to5', nrow(info(sv_callset_vcf))),
                                      levels = c('5to5', '3to3', '3to5', '5to3')
                                    )))
      # TRA
      idx <- which(info(sv_callset_vcf)$SVTYPE == 'TRA')
      if (length(idx) > 0) {
        info(sv_callset_vcf)$CT[idx[seq(1, length(idx), by = 2)]] <- '3to3'
        info(sv_callset_vcf)$CT[idx[seq(2, length(idx), by = 2)]] <-
          '5to5'
      }
    }
}

# Not including breakends (unpaired breakpoints)
# bpgr <- breakpointRanges(sv_callset_vcf)
# breakends are excluded
# begr <- breakendRanges(sv_callset_vcf)
# gr <- sort(c(bpgr, begr))

# generate SV IDs as 'svtype_chromosome_position'
sv_callset_vcf.ids <-
  paste(substr(as.character(mcols(
    rowRanges(sv_callset_vcf)
  )$ALT), 2, 4),
  seqnames(rowRanges(sv_callset_vcf)),
  start(rowRanges(sv_callset_vcf)),
  sep = "_")

# SVA considers some DELs generated by SURVIVOR as INS
gr <- StructuralVariantAnnotation::breakpointRanges(sv_callset_vcf)

#print('SVTYPEs loaded with StructuralVariantAnnotation::breakpointRanges')
#print(table(gr$svtype))

gr.ids <-
  paste(substr(as.character(mcols(
    rowRanges(sv_callset_vcf)
  )$ALT), 2, 4),
  seqnames(rowRanges(sv_callset_vcf)),
  start(rowRanges(sv_callset_vcf)),
  sep = "_")

gr <- apply_svtype(gr, p_inslen = argv$p)
# select SVs >= 50 bp. svLen==NA for svtype=='BP'
gr <- gr[abs(gr$svLen) >= argv$l | gr$svtype == 'CTX']

bedpe <- StructuralVariantAnnotation::breakpointgr2bedpe(gr)

# create a vector with mappings: sourceId -> svtype
svtype_vec <- gr$svtype
names(svtype_vec) <- names(gr)

# typeof(svtype_vec) must be equal to typeof(bedpe_keys)
bedpe_keys <- as.vector(bedpe[, 7])

bedpe_svtype <- cbind(bedpe[, 1:6], SVTYPE = svtype_vec[bedpe_keys], name = bedpe$name)

# inversions should be one per line in the BEDPE file
bedpe.ins <- bedpe_svtype[bedpe_svtype$SVTYPE=='INV',]

bedpe.ins <- bedpe.ins[grep(as.character(bedpe.ins$name), pattern='_bp1'),]

bedpe_svtype <- rbind(
  bedpe_svtype[bedpe_svtype$SVTYPE!='INV',],
  bedpe.ins
)
# remove the name
bedpe_svtype <- bedpe_svtype[,-which(names(bedpe_svtype)=='name')]

# check that all SVs with svtype==BP have breakpoints on different chromosomes
if (any(bedpe_svtype[, 1] == bedpe_svtype[, 4] &
        bedpe_svtype[, 7] == 'CTX'))
{
  stop("Some SVs with svtype BP contain breakpoints that are both on the same chromosomes")
}

print('SVTYPEs in BEDPE output:')
print(table(bedpe_svtype$SVTYPE))

#only write deletions
bedpe_svtype <- bedpe_svtype[which(bedpe_svtype$SVTYPE=='DEL'),]

# write output in BEDPE
write.table(
  file = argv$o,
  bedpe_svtype,
  quote = FALSE,
  row.names = FALSE,
  col.names = FALSE,
  sep = '\t'
)
